{"ReceiverIR.cpp":"/**\r\n * IR receiver (Version 0.0.4)\r\n *\r\n * Copyright (C) 2010 Shinichiro Nakamura (CuBeatSystems)\r\n * http://shinta.main.jp/\r\n */\r\n\r\n#include \"ReceiverIR.h\"\r\n\r\n#define LOCK()\r\n#define UNLOCK()\r\n\r\n#define InRange(x,y)   ((((y) * 0.7) < (x)) && ((x) < ((y) * 1.3)))\r\n\r\n/**\r\n * Constructor.\r\n *\r\n * @param rxpin Pin for receive IR signal.\r\n */\r\nReceiverIR::ReceiverIR(PinName rxpin) : evt(rxpin) {\r\n    init_state();\r\n    evt.fall(this, &ReceiverIR::isr_fall);\r\n    evt.rise(this, &ReceiverIR::isr_rise);\r\n    evt.mode(PullUp);\r\n    ticker.attach_us(this, &ReceiverIR::isr_wdt, 10 * 1000);\r\n}\r\n\r\n/**\r\n * Destructor.\r\n */\r\nReceiverIR::~ReceiverIR() {\r\n}\r\n\r\n/**\r\n * Get state.\r\n *\r\n * @return Current state.\r\n */\r\nReceiverIR::State ReceiverIR::getState() {\r\n    LOCK();\r\n    State s = work.state;\r\n    UNLOCK();\r\n    return s;\r\n}\r\n\r\n/**\r\n * Get data.\r\n *\r\n * @param format Pointer to format.\r\n * @param buf Buffer of a data.\r\n * @param bitlength Bit length of the buffer.\r\n *\r\n * @return Data bit length.\r\n */\r\nint ReceiverIR::getData(RemoteIR::Format *format, uint8_t *buf, int bitlength) {\r\n    LOCK();\r\n    if (bitlength < data.bitcount) {\r\n        UNLOCK();\r\n        return -1;\r\n    }\r\n\r\n    const int nbits = data.bitcount;\r\n    const int nbytes = data.bitcount / 8 + (((data.bitcount % 8) != 0) ? 1 : 0);\r\n    *format = data.format;\r\n    for (int i = 0; i < nbytes; i++) {\r\n        buf[i] = data.buffer[i];\r\n    }\r\n\r\n    init_state();\r\n\r\n    UNLOCK();\r\n    return nbits;\r\n}\r\n\r\nvoid ReceiverIR::init_state(void) {\r\n    work.c1 = -1;\r\n    work.c2 = -1;\r\n    work.c3 = -1;\r\n    work.d1 = -1;\r\n    work.d2 = -1;\r\n    work.state = Idle;\r\n    data.format = RemoteIR::UNKNOWN;\r\n    data.bitcount = 0;\r\n    timer.stop();\r\n    timer.reset();\r\n    for (int i = 0; i < sizeof(data.buffer); i++) {\r\n        data.buffer[i] = 0;\r\n    }\r\n}\r\n\r\nvoid ReceiverIR::isr_wdt(void) {\r\n    LOCK();\r\n    static int cnt = 0;\r\n    if ((Idle != work.state) || ((0 <= work.c1) || (0 <= work.c2) || (0 <= work.c3) || (0 <= work.d1) || (0 <= work.d2))) {\r\n        cnt++;\r\n        if (cnt > 50) {\r\n#if 0\r\n            printf(\"# WDT [c1=%d, c2=%d, c3=%d, d1=%d, d2=%d, state=%d, format=%d, bitcount=%d]\\n\",\r\n                   work.c1,\r\n                   work.c2,\r\n                   work.c3,\r\n                   work.d1,\r\n                   work.d2,\r\n                   work.state,\r\n                   data.format,\r\n                   data.bitcount);\r\n#endif\r\n            init_state();\r\n            cnt = 0;\r\n        }\r\n    } else {\r\n        cnt = 0;\r\n    }\r\n    UNLOCK();\r\n}\r\n\r\nvoid ReceiverIR::isr_fall(void) {\r\n    LOCK();\r\n    switch (work.state) {\r\n        case Idle:\r\n            if (work.c1 < 0) {\r\n                timer.start();\r\n                work.c1 = timer.read_us();\r\n            } else {\r\n                work.c3 = timer.read_us();\r\n                int a = work.c2 - work.c1;\r\n                int b = work.c3 - work.c2;\r\n                if (InRange(a, RemoteIR::TUS_NEC * 16) && InRange(b, RemoteIR::TUS_NEC * 8)) {\r\n                    /*\r\n                     * NEC.\r\n                     */\r\n                    data.format = RemoteIR::NEC;\r\n                    work.state = Receiving;\r\n                    data.bitcount = 0;\r\n                } else if (InRange(a, RemoteIR::TUS_NEC * 16) && InRange(b, RemoteIR::TUS_NEC * 4)) {\r\n                    /*\r\n                     * NEC Repeat.\r\n                     */\r\n                    data.format = RemoteIR::NEC_REPEAT;\r\n                    work.state = Received;\r\n                    data.bitcount = 0;\r\n                    work.c1 = -1;\r\n                    work.c2 = -1;\r\n                    work.c3 = -1;\r\n                    work.d1 = -1;\r\n                    work.d2 = -1;\r\n                } else if (InRange(a, RemoteIR::TUS_AEHA * 8) && InRange(b, RemoteIR::TUS_AEHA * 4)) {\r\n                    /*\r\n                     * AEHA.\r\n                     */\r\n                    data.format = RemoteIR::AEHA;\r\n                    work.state = Receiving;\r\n                    data.bitcount = 0;\r\n                } else if (InRange(a, RemoteIR::TUS_AEHA * 8) && InRange(b, RemoteIR::TUS_AEHA * 8)) {\r\n                    /*\r\n                     * AEHA Repeat.\r\n                     */\r\n                    data.format = RemoteIR::AEHA_REPEAT;\r\n                    work.state = Received;\r\n                    data.bitcount = 0;\r\n                    work.c1 = -1;\r\n                    work.c2 = -1;\r\n                    work.c3 = -1;\r\n                    work.d1 = -1;\r\n                    work.d2 = -1;\r\n                } else {\r\n                    init_state();\r\n                }\r\n            }\r\n            break;\r\n        case Receiving:\r\n            if (RemoteIR::NEC == data.format) {\r\n                work.d2 = timer.read_us();\r\n                int a = work.d2 - work.d1;\r\n                if (InRange(a, RemoteIR::TUS_NEC * 3)) {\r\n                    data.buffer[data.bitcount / 8] |= (1 << (data.bitcount % 8));\r\n                } else if (InRange(a, RemoteIR::TUS_NEC * 1)) {\r\n                    data.buffer[data.bitcount / 8] &= ~(1 << (data.bitcount % 8));\r\n                }\r\n                data.bitcount++;\r\n#if 1\r\n                /*\r\n                 * Length of NEC is always 32 bits.\r\n                 */\r\n                if (32 <= data.bitcount) {\r\n                    work.state = Received;\r\n                    work.c1 = -1;\r\n                    work.c2 = -1;\r\n                    work.c3 = -1;\r\n                    work.d1 = -1;\r\n                    work.d2 = -1;\r\n                }\r\n#else\r\n                /*\r\n                 * Set timeout for tail detection automatically.\r\n                 */\r\n                timeout.detach();\r\n                timeout.attach_us(this, &ReceiverIR::isr_timeout, RemoteIR::TUS_NEC * 5);\r\n#endif\r\n            } else if (RemoteIR::AEHA == data.format) {\r\n                work.d2 = timer.read_us();\r\n                int a = work.d2 - work.d1;\r\n                if (InRange(a, RemoteIR::TUS_AEHA * 3)) {\r\n                    data.buffer[data.bitcount / 8] |= (1 << (data.bitcount % 8));\r\n                } else if (InRange(a, RemoteIR::TUS_AEHA * 1)) {\r\n                    data.buffer[data.bitcount / 8] &= ~(1 << (data.bitcount % 8));\r\n                }\r\n                data.bitcount++;\r\n#if 0\r\n                /*\r\n                 * Typical length of AEHA is 48 bits.\r\n                 * Please check a specification of your remote controller if you find a problem.\r\n                 */\r\n                if (48 <= data.bitcount) {\r\n                    data.state = Received;\r\n                    work.c1 = -1;\r\n                    work.c2 = -1;\r\n                    work.c3 = -1;\r\n                    work.d1 = -1;\r\n                    work.d2 = -1;\r\n                }\r\n#else\r\n                /*\r\n                 * Set timeout for tail detection automatically.\r\n                 */\r\n                timeout.detach();\r\n                timeout.attach_us(this, &ReceiverIR::isr_timeout, RemoteIR::TUS_AEHA * 5);\r\n#endif\r\n            } else if (RemoteIR::SONY == data.format) {\r\n                work.d1 = timer.read_us();\r\n            }\r\n            break;\r\n        case Received:\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    UNLOCK();\r\n}\r\n\r\nvoid ReceiverIR::isr_rise(void) {\r\n    LOCK();\r\n    switch (work.state) {\r\n        case Idle:\r\n            if (0 <= work.c1) {\r\n                work.c2 = timer.read_us();\r\n                int a = work.c2 - work.c1;\r\n                if (InRange(a, RemoteIR::TUS_SONY * 4)) {\r\n                    data.format = RemoteIR::SONY;\r\n                    work.state = Receiving;\r\n                    data.bitcount = 0;\r\n                } else {\r\n                    static const int MINIMUM_LEADER_WIDTH = 150;\r\n                    if (a < MINIMUM_LEADER_WIDTH) {\r\n                        init_state();\r\n                    }\r\n                }\r\n            } else {\r\n                init_state();\r\n            }\r\n            break;\r\n        case Receiving:\r\n            if (RemoteIR::NEC == data.format) {\r\n                work.d1 = timer.read_us();\r\n            } else if (RemoteIR::AEHA == data.format) {\r\n                work.d1 = timer.read_us();\r\n            } else if (RemoteIR::SONY == data.format) {\r\n                work.d2 = timer.read_us();\r\n                int a = work.d2 - work.d1;\r\n                if (InRange(a, RemoteIR::TUS_SONY * 2)) {\r\n                    data.buffer[data.bitcount / 8] |= (1 << (data.bitcount % 8));\r\n                } else if (InRange(a, RemoteIR::TUS_SONY * 1)) {\r\n                    data.buffer[data.bitcount / 8] &= ~(1 << (data.bitcount % 8));\r\n                }\r\n                data.bitcount++;\r\n#if 1\r\n                /*\r\n                 * How do I know the correct length? (6bits, 12bits, 15bits, 20bits...)\r\n                 * By a model only?\r\n                 * Please check a specification of your remote controller if you find a problem.\r\n                 */\r\n                if (32 <= data.bitcount) {\r\n                    work.state = Received;\r\n                    work.c1 = -1;\r\n                    work.c2 = -1;\r\n                    work.c3 = -1;\r\n                    work.d1 = -1;\r\n                    work.d2 = -1;\r\n                }\r\n#else\r\n                /*\r\n                 * Set timeout for tail detection automatically.\r\n                 */\r\n                timeout.detach();\r\n                timeout.attach_us(this, &ReceiverIR::isr_timeout, RemoteIR::TUS_SONY * 4);\r\n#endif\r\n            }\r\n            break;\r\n        case Received:\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    UNLOCK();\r\n}\r\n\r\nvoid ReceiverIR::isr_timeout(void) {\r\n    LOCK();\r\n#if 0\r\n    printf(\"# TIMEOUT [c1=%d, c2=%d, c3=%d, d1=%d, d2=%d, state=%d, format=%d, bitcount=%d]\\n\",\r\n           work.c1,\r\n           work.c2,\r\n           work.c3,\r\n           work.d1,\r\n           work.d2,\r\n           work.state,\r\n           data.format,\r\n           data.bitcount);\r\n#endif\r\n    if (work.state == Receiving) {\r\n        printf(\"done\\r\\n\");\r\n        work.state = Received;\r\n        work.c1 = -1;\r\n        work.c2 = -1;\r\n        work.c3 = -1;\r\n        work.d1 = -1;\r\n        work.d2 = -1;\r\n    }\r\n    UNLOCK();\r\n}\r\n","ReceiverIR.h":"/**\r\n * IR receiver (Version 0.0.4)\r\n *\r\n * Copyright (C) 2010 Shinichiro Nakamura (CuBeatSystems)\r\n * http://shinta.main.jp/\r\n */\r\n\r\n#ifndef _RECEIVER_IR_H_\r\n#define _RECEIVER_IR_H_\r\n\r\n#include <mbed.h>\r\n\r\n#include \"RemoteIR.h\"\r\n\r\n/**\r\n * IR receiver class.\r\n */\r\nclass ReceiverIR {\r\npublic:\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param rxpin Pin for receive IR signal.\r\n     */\r\n    explicit ReceiverIR(PinName rxpin);\r\n    \r\n    /**\r\n     * Destructor.\r\n     */\r\n    ~ReceiverIR();\r\n\r\n    /**\r\n     * State.\r\n     */\r\n    typedef enum {\r\n        Idle,\r\n        Receiving,\r\n        Received\r\n    } State;\r\n    \r\n    /**\r\n     * Get state.\r\n     *\r\n     * @return Current state.\r\n     */\r\n    State getState();\r\n    \r\n    /**\r\n     * Get data.\r\n     *\r\n     * @param format Pointer to format.\r\n     * @param buf Buffer of a data.\r\n     * @param bitlength Bit length of the buffer.\r\n     *\r\n     * @return Data bit length.\r\n     */\r\n    int getData(RemoteIR::Format *format, uint8_t *buf, int bitlength);\r\n    \r\nprivate:\r\n    \r\n    typedef struct {\r\n        RemoteIR::Format format;\r\n        int bitcount;\r\n        uint8_t buffer[64];\r\n    } data_t;\r\n    \r\n    typedef struct {\r\n        State state;\r\n        int c1;\r\n        int c2;\r\n        int c3;\r\n        int d1;\r\n        int d2;\r\n    } work_t;\r\n\r\n    InterruptIn evt;    /**< Interrupt based input for input. */\r\n    Timer timer;        /**< Timer for WDT. */\r\n    Ticker ticker;      /**< Tciker for tick. */\r\n    Timeout timeout;    /**< Timeout for tail. */\r\n\r\n    data_t data;\r\n    work_t work;\r\n    \r\n    void init_state(void);\r\n\r\n    void isr_wdt(void);\r\n    void isr_fall(void);\r\n    void isr_rise(void);\r\n    \r\n    /**\r\n     * ISR timeout for tail detection.\r\n     */\r\n    void isr_timeout(void);\r\n\r\n};\r\n\r\n#endif\r\n","RemoteIR.h":"/**\r\n * IR remote common class (Version 0.0.4)\r\n *\r\n * Copyright (C) 2010 Shinichiro Nakamura (CuBeatSystems)\r\n * http://shinta.main.jp/\r\n */\r\n\r\n#ifndef _REMOTE_IR_H_\r\n#define _REMOTE_IR_H_\r\n\r\nclass RemoteIR {\r\npublic:\r\n\r\n    typedef enum {\r\n        UNKNOWN,\r\n        NEC,\r\n        NEC_REPEAT,\r\n        AEHA,\r\n        AEHA_REPEAT,\r\n        SONY\r\n    } Format;\r\n\r\n    static const int TUS_NEC = 562;\r\n    static const int TUS_AEHA = 425;\r\n    static const int TUS_SONY = 600;\r\n\r\nprivate:\r\n    RemoteIR();\r\n};\r\n\r\n#endif\r\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    declare const enum Pins {\n    P0 = 3,\n    P1 = 2,\n    P2 = 1,\n    P3 = 4,\n    P4 = 5,\n    P5 = 17,\n    P6 = 12,\n    P7 = 11,\n    P8 = 18,\n    P9 = 10,\n    P10 = 6,\n    P11 = 26,\n    P12 = 20,\n    P13 = 23,\n    P14 = 22,\n    P15 = 21,\n    P16 = 16,\n    P19 = 0,\n    P20 = 30,\n    }\n\n\n    declare const enum RemoteButton {\n    POWER = 0x0,\n    Up = 0x5,\n    Left = 0x8,\n    Right = 0xA,\n    Down = 0xD,\n    OK = 0x9,\n    Plus = 0x4,\n    Minus = 0xC,\n    Back = 0x6,\n    }\ndeclare namespace IR {\n}\n\n// Auto-generated. Do not edit. Really.\n","ir.cpp":"#include \"pxt.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"ReceiverIR.h\"\r\nusing namespace pxt;\r\ntypedef vector<Action> vA;\r\n\r\nenum class Pins{\r\n  P0=  3,\r\n  P1=  2,\r\n  P2=  1,\r\n  P3=  4,\r\n  P4=  5,\r\n  P5=  17,\r\n  P6=  12,\r\n  P7=  11,\r\n  P8=  18,\r\n  P9=  10,\r\n  P10= 6,\r\n  P11= 26,\r\n  P12= 20,\r\n  P13= 23,\r\n  P14= 22,\r\n  P15= 21,\r\n  P16= 16,\r\n  P19= 0,\r\n  P20= 30\r\n};\r\n\r\nenum class RemoteButton {\r\n  POWER = 0x0,\r\n  Up = 0x5,\r\n  Left = 0x8,\r\n  Right = 0xA,\r\n  Down = 0xD,\r\n  OK = 0x9,\r\n  Plus = 0x4,\r\n  Minus = 0xC,\r\n  Back = 0x6\r\n};\r\n\r\n//% color=50 weight=80\r\n//% icon=\"\\uf1eb\"\r\nnamespace IR { \r\n  map<RemoteButton, vA> actions;\r\n  map<RemoteButton, uint32_t> lastact;\r\n  Timer tsb; \r\n  uint8_t buf[32];\r\n  uint32_t now;\r\n  ReceiverIR *rx;\r\n  RemoteIR::Format fmt = RemoteIR::UNKNOWN;\r\n\r\n\r\n  void cA(vA runner){for(int i=0;i<runner.size();i++){runAction0(runner[i]);} }\r\n\r\n  void onReceivable(){\r\n    int x = rx->getData(&fmt, buf, 32 * 8);\r\n    if(actions.find((RemoteButton)buf[2]) == actions.end()) return;\r\n    now = tsb.read_ms();\r\n    if(now - lastact[(RemoteButton)buf[2]] < 100) return;\r\n    lastact[(RemoteButton)buf[2]] = now;\r\n    cA(actions[(RemoteButton)buf[2]]); \r\n  }\r\n\r\n  void monitorIR(){\r\n    while(1){\r\n      while(rx->getState() != ReceiverIR::Received){ \r\n        uBit.sleep(50);\r\n      }\r\n      onReceivable();\r\n    }\r\n  }\r\n\r\n  //%\r\n  void init(Pins pin){\r\n    rx = new ReceiverIR((PinName)pin);\r\n    tsb.start(); //interrupt timer for debounce\r\n    create_fiber(monitorIR);\r\n  }\r\n\r\n  //% \r\n  void onPressEvent(RemoteButton btn, Action body) {\r\n    //if(actions.find(btn) == actions.end()) actions[btn] = new vector();\r\n    actions[btn].push_back(body);\r\n  }\r\n}","main.ts":"\r\n\r\n/**\r\n * IR remote\r\n */\r\n    //% color=50 weight=80\r\n    //% icon=\"\\uf1eb\"\r\nnamespace IR {\r\n\r\n  /**\r\n  * initialization\r\n  */\r\n  //% blockId=ir_init\r\n  //% blockGap=20 weight=90\r\n  //% block=\"connect ir receiver to %pin\"\r\n  //% shim=IR::init\r\n  export function init(pin: Pins): void {\r\n    return\r\n  }\r\n\r\n  /**\r\n  * button pushed.\r\n  */\r\n  //% blockId=ir_received_event\r\n  //% blockGap=20 weight=70\r\n  //% block=\"on |%btn| button pressed\"\r\n  //% shim=IR::onPressEvent\r\n  export function onPressEvent(btn: RemoteButton, body:Action): void {\r\n    return\r\n  }\r\n\r\n}\r\n","pxt.json":"{\n    \"name\": \"ir\",\n    \"version\": \"0.1.2\",\n    \"description\": \"Tinkercademy package for ElecFreaks IR receiver module\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"ir.cpp\",\n        \"ReceiverIR.cpp\",\n        \"ReceiverIR.h\",\n        \"RemoteIR.h\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"branch\": \"v2.2.3\",\n        \"tag\": \"v2.2.3\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/ccca92bab83392a5d59c106012a1b4d299892882\",\n        \"target\": \"2.2.3\",\n        \"pxt\": \"5.35.1\"\n    }\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n\n    //% color=50 weight=80\n    //% icon=\"\\uf1eb\"\ndeclare namespace IR {\n}\n\n// Auto-generated. Do not edit. Really.\n"}